---
title: 16、构造函数模式与原型链模式
categories: 面向对象与继承
toc: true
---
# 构造函数设计模式
使用构造函数方式，主要是为了创建类和实例的，也就是基于面向对象思想来实现一些需求

在JS中，当我们使用new xxx()执行函数的时候，此时的函数就不是普通的函数了，而是变为一个类，返回的结果叫做当前类的实例，我们这种new xxx执行的方式称之为`构造函数设计模式`
```javascript
function fn(){

}
new fn();
```
# 构造函数执行时new都干了些什么？
在new Fn()，执行的时候，是先把函数执行了，也就是后面的Fn()先执行，形成一个私有作用域，形参赋值变量提升，在变量提升完了之后，new操作符才起了作用，这个时候，浏览器开始创建一个新的对象，让Fn中的this指向这个新创建的对象，然后让这个对象的\__proto__指向Fn.prototype，然后JS代码才开始继续往下执行，开始往新创建的对象当中添加每个实例私有的属性和方法。JS代码执行完成后，会默认返回当前创建的这个对象。
![](http://ww1.sinaimg.cn/large/0067rNTTly1fpmvd8zm9ej30qy09qjtc.jpg)

# 普通函数执行与构造函数执行的区别
构造函数执行的时候，也是先形成一个私有作用域，形参赋值，变量提升，在代码从上而下执行之前，构造函数有特殊的操作：`浏览器会在当前的作用域中默认创建一个对象数据类型的值，并且会让当前函数中的this指向创建的这个对象。`然后JS代码再执行，代码执行完成后，即使函数中没有写return，在构造函数模式中：`浏览器会默认的把创建的对象返回到函数外面`
<font color=red>**总结：**</font>
 + 构造函数执行期间，既具备函数执行的一面，也同时具备自己独有的操作：在构造函数执行期间，浏览器会默认创建一个对象，这个对象就是当前这个构造函数(类)实例，函数执行完成后，浏览器会默认的把这个实例返回。所以new Fn()执行，Fn是一个类，`返回的结果`就是Fn这个类的一个实例

# 构造函数执行后面的‘()’问题
构造函数执行如果不需要传递参数，函数后面的()可省略，如`new Fn()`可写为`new Fn`；
**`注意`**：
 - 如果要在new Fn之后直接调用实例的方法，则必须要加小括号，即必须写成`new Fn().方法名`

# 构造函数模式的返回值问题
**构造函数模式中默认返回值是当前的实例，如果有return,返回分2种情况：**
1、return 后面是一个基本数据类型的值，当前实例是不变的，例如return 100；我们的返回值还是当前类的实例；
2、return 后面是一个引用数据类型的值，当前实例会被返回的值给替换掉例如return {name:"珠峰"}我们的返回值就不再是当前类的实例了，而是对象 {name:"珠峰"}；
# A instanceof B
检测某一个实例是否属于这个类, 判断A实例是否属于B类
# attr in object
检测attr是否是object的属性，不管是私有属性还是公有属性（在原型链上找的到）只要存在，用in来检测都是true
# a.hasOwnProperty(attr)
检测attr是否是A实例的私有属性
# 对象数据类型的
+ 普通对象
+ 数组
+ 正则
+ Math数学函数
+ 一般类的实例
+ 函数的prototype属性（Function.prototype除外，它是函数数据类型的）
+ 实例的\__proto__属性

# 函数数据类型的
+ 普通函数
+ 所有的类(内置类和自定义类都是)

# 原型链模式
**基于构造函数模式的原型链模式解决了方法或者属性公有的问题，把实例之间公有的属性和方法写在当前类的prototype属性上；**
**1、每一个函数数据类型都有一个天生自带的属性：prototype（原型），并且这个属性的属性值是一个对象数据类型的值(<font color=red>Function.prototype是函数数据类型的,但是它没有prototype属性（Function.prototype.prototype是undefined）。Array.prototype是一个数组</font>)，浏览器默认为其开辟一个堆内存；**
**2、在浏览器给prototype开辟的这个堆内存中，浏览器天生给它加了一个constructor属性（构造函数），属性值是当前函数（类）本身；**
**3、每一个对象数据类型(普通对象、数组、正则、实例、protoype..)也天生自带一个属性:\__proto__，属性值指向当前实例所属类的原型(prototype);**
**`(IE中屏蔽了对象的__proto__属性，但是确实有，只是不让我们使用而已)`**
**4、Object是JS中所有对象数据类型的基类（最顶层的类）；**
## 原型链模式中的this
原型模式中的this分两种情况：
 1、 在类中this.xxx=xxx;this->当前类的实例
 2、 原型链中提供的私有(公有)方法中的this问题：
 **`总结`：**看执行的时候"."前面是谁this就是谁。具体操作步骤如下
 + 1、需要先确定this的指向（this）
 + 2、把this替换成对应的的代码
 + 3、按照原型链查找的机制，一步步的查找结果

## 如何往原型中批量添加属性和方法
重构原型
让某个构造函数的原型指向我们自己开辟的堆内存，但是自己开辟的堆内存当中是没有constructor属性的，所以要往自己开辟的堆内存中添加constructor属性，属性值为当前构造函数本身；
缺点：重构原型后，会导致之前添加的属性和方法都没有了，只能使用重构之后添加的属性和方法；
**`注意：`**
 + 不要忘了重构之后要添加constructor属性指向当前构造函数；
 + 内置类的原型不能重构，浏览器不允许我们这么做；
 + 重构原型之前生成的实例的`__proto__`属性值依然指向重构之前的原型，而不是重构之后的原型，只有在重构原型之后生成的实例的`__proto__`属性值才指向新的原型；
